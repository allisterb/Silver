using Stratis.SmartContracts;
using System;

[Deploy]
public class DAOContract : SmartContract
{
    public Address Owner
    {
        get {return State.GetAddress("Owner");}
        private set {State.SetAddress("Owner", value);}
    }

    public uint MinQuorum  {get{return WhitelistedCount / 2 + 1;}}

    public uint WhitelistedCount
    {
        get {return State.GetUInt32("WhitelistedCount");}
        private set {State.SetUInt32("WhitelistedCount", value);}
    }

    public uint MinVotingDuration
    {
        get {return State.GetUInt32("MinVotingDuration");}
        private set {State.SetUInt32("MinVotingDuration", value);}
    }

    public uint MaxVotingDuration
    {
        get {return State.GetUInt32("MaxVotingDuration");}
        private set {State.SetUInt32("MaxVotingDuration", value);}
    }

    public uint LastProposalId
    {
        get {return State.GetUInt32("LastProposalId");}
        private set {State.SetUInt32("LastProposalId", value);}
    }

    public bool IsWhitelisted(Address address)  {return State.GetBool(string.Format("Whitelisted:{0}",address));}
    private void SetIsWhitelisted(Address address, bool allowed)  {State.SetBool(string.Format("Whitelisted:{0}",address), allowed);}

    public ulong GetVotingDeadline(uint proposalId)  {return State.GetUInt64(string.Format("Deadline:{0}",proposalId));}
    private void SetVotingDeadline(uint proposalId, ulong block)  {State.SetUInt64(string.Format("Deadline:{0}",proposalId), block);}

    public uint GetYesVotes(uint proposalId)  {return State.GetUInt32(string.Format("YesVotes:{0}",proposalId));}
    private void SetYesVotes(uint proposalId, uint value)  {State.SetUInt32(string.Format("YesVotes:{0}",proposalId), value);}

    public uint GetNoVotes(uint proposalId)  {return State.GetUInt32(string.Format("NoVotes:{0}",proposalId));}
    private void SetNoVotes(uint proposalId, uint value)  {State.SetUInt32(string.Format("NoVotes:{0}",proposalId), value);}

    public uint GetVote(uint proposalId, Address address)  {return State.GetUInt32(string.Format("Vote:{0}:{1}",proposalId,address));}
    private void SetVote(uint proposalId, Address address, Votes vote)  {State.SetUInt32(string.Format("Vote:{0}:{1}",proposalId,address), (uint)vote);}

    public Proposal GetProposal(uint index)  {return State.GetStruct<Proposal>(string.Format("Proposals:{0}",index));}

    private void SetProposal(uint index, Proposal proposal)  {State.SetStruct(string.Format("Proposals:{0}",index), proposal);}

    public const uint DefaultMaxDuration = 60u * 60 * 24 * 7 / 16; // 1 week period as second/ block duration as second
    public DAOContract(ISmartContractState state, uint minVotingDuration)
        : base(state)
    {
        assume DefaultMaxDuration > minVotingDuration;

        Owner = Message.Sender;
        LastProposalId = 1;
        MinVotingDuration = minVotingDuration;
        MaxVotingDuration = DefaultMaxDuration;
    }

    public uint CreateProposal(Address recipent, ulong amount, uint votingDuration, string description)
    {
        EnsureNotPayable();

        assume votingDuration > MinVotingDuration && votingDuration < MaxVotingDuration;

        int length = description != null ? description.Length : 0;
        assume length <= 200;

        Proposal proposal = new Proposal();

        proposal.RequestedAmount = amount;
        proposal.Description = description;
        proposal.Recipient = recipent;
        proposal.Owner = Message.Sender;
        

        uint proposalId = LastProposalId;
        SetProposal(proposalId, proposal);
        SetVotingDeadline(proposalId, checked(votingDuration + Block.Number));
        Log(new ProposalAddedLog
        {
            ProposalId = proposalId,
            Recipent = recipent,
            Amount = amount,
            Description = description
        });

        LastProposalId = proposalId + 1;

        return proposalId;
    }

    public void Vote(uint proposalId, bool vote)
    {
        EnsureNotPayable();
        assume IsWhitelisted(Message.Sender);

        assume GetVotingDeadline(proposalId) > Block.Number;

        VoteProposal(proposalId, ToVote(vote));
    }

    private void VoteProposal(uint proposalId, Votes vote)
    {
        Votes currentVote = (Votes)GetVote(proposalId, Message.Sender);

        if (currentVote == vote)
        {
            return;
        }

        Unvote(proposalId, currentVote);
        SetVote(proposalId, Message.Sender, vote);

        Log(new ProposalVotedLog { ProposalId = proposalId, Voter = Message.Sender, Vote = vote == Votes.Yes });

        if (vote == Votes.Yes)
        {
            SetYesVotes(proposalId, GetYesVotes(proposalId) + 1);
        }
        else
        {
            SetNoVotes(proposalId, GetNoVotes(proposalId) + 1);
        }
    }

    private void Unvote(uint proposalId, Votes currentVote)
    {
        switch (currentVote)
        {
            case Votes.Yes: SetYesVotes(proposalId, GetYesVotes(proposalId) - 1); break;
            case Votes.No: SetNoVotes(proposalId, GetNoVotes(proposalId) - 1); break;
            case Votes.None: break;
        }
    }

    private Votes ToVote(bool vote)  {return vote ? Votes.Yes : Votes.No;}

    public void ExecuteProposal(uint proposalId)
    {
        EnsureNotPayable();

        Proposal proposal = GetProposal(proposalId);

        uint yesVotes = GetYesVotes(proposalId);
        uint noVotes = GetNoVotes(proposalId);

        assume yesVotes > noVotes;

        assume yesVotes >= MinQuorum;

        assume !proposal.Executed;
        assume GetVotingDeadline(proposalId) < Block.Number;
        assume proposal.RequestedAmount <= Balance;

        proposal.Executed = true;
        SetProposal(proposalId, proposal);
        ITransferResult result = Transfer(proposal.Recipient, proposal.RequestedAmount);

        assume result.Success;

        Log(new ProposalExecutedLog { ProposalId = proposalId, Amount = proposal.RequestedAmount, Recipent = proposal.Recipient });

    }

    public void BlacklistAddress(Address address)
    {
        EnsureOwnerOnly();

        if (!IsWhitelisted(address))
            return;

        SetIsWhitelisted(address, false);
        WhitelistedCount--;
    }

    public void BlacklistAddresses(byte[] addresses)
    {
        EnsureOwnerOnly();
        foreach (Address address in Serializer.ToArray<Address>(addresses))
        {
            if (!IsWhitelisted(address))
                continue;

            SetIsWhitelisted(address, false);
            WhitelistedCount--;
        }
    }

    public void WhitelistAddress(Address address)
    {
        EnsureOwnerOnly();

        if (IsWhitelisted(address))
            return;

        SetIsWhitelisted(address, true);

        WhitelistedCount++;
    }

    public void WhitelistAddresses(byte[] addresses)
    {
        EnsureOwnerOnly();
        foreach (Address address in Serializer.ToArray<Address>(addresses))
        {
            if (IsWhitelisted(address))
                continue;

            SetIsWhitelisted(address, true);
            WhitelistedCount++;
        }
    }

    public void Deposit()
    {
        EnsureOwnerOnly();
        Log(new FundRaisedLog { Sender = Message.Sender, Amount = Message.Value });
    }

    public override void Receive()  {Deposit();}

    public void TransferOwnership(Address newOwner)
    {
        EnsureOwnerOnly();
        Owner = newOwner;
    }

    public void UpdateMinVotingDuration(uint minVotingDuration)
    {
        EnsureOwnerOnly();

        assume minVotingDuration < MaxVotingDuration;

        MinVotingDuration = minVotingDuration;
    }

    public void UpdateMaxVotingDuration(uint maxVotingDuration)
    {
        EnsureOwnerOnly();
        assume maxVotingDuration > MinVotingDuration;

        MaxVotingDuration = maxVotingDuration;
    }

    private void EnsureOwnerOnly()  {assume this.Owner == Message.Sender;}
    private void EnsureNotPayable()  {assume Message.Value == 0;}

    public enum Votes : uint
    {
        None,
        No,
        Yes
    }

    public struct ProposalAddedLog
    {
        [Index]
        public Address Recipent;
        [Index]
        public uint ProposalId;
        public ulong Amount;
        public string Description;
    }
    public struct ProposalExecutedLog
    {
        [Index]
        public Address Recipent;
        [Index]
        public uint ProposalId;
        public ulong Amount;
    }
    public struct FundRaisedLog
    {
        [Index]
        public Address Sender;
        public ulong Amount;
    }
    public struct ProposalVotedLog
    {
        [Index]
        public uint ProposalId;
        [Index]
        public Address Voter;
        public bool Vote;
    }

    public struct Proposal
    {
        public Address Owner;

        public Address Recipient;

        public ulong RequestedAmount;


        public string Description;

        /// <summary>
        /// True if proposal executed and the requested fund is transferred
        /// </summary>
        public bool Executed;
    }
}
